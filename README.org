* Local instances
** Without Cicero
The ~plutus-certification~ program has a ~--local~ flag to run the service locally without using ~Cicero~ as a backend. While this is much faster and easier to set up, it has caveats:

- The code built from submitted runs is run unsandboxed. *Do not submit untrusted code to an instance running in local mode!*
- There will be divergence from how the service runs in production. We share many code paths (see ~dapps-certification-helpers~), but not all
** With Cicero
1. Check out the ~v1-maintenance~ branch
2. Run ~nix develop --command nixos-shell --flake .#vm-bigdisk~
3. Log in as root
4. Run dev-cicero
5. Open your browser to ~localhost:18080~
6. Click "Create New Action"
7. Input ~github.com/input-output-hk/dapps-certification-actions~ (or your own [[https://github.com/hashicorp/go-getter#url-format][go-getter URL]]) and list actions
8. Click ~plutus-certification/build-flake~, then once loaded go back and click ~plutus-certification/generate-flake~, then once loaded go back and click ~plutus-certification/run-certify~

Now ~Cicero~ is running at http://localhost:18080, which you can pass as ~--cicero-url~ to ~plutus-certification~.

** In local-mode
In order to run the service in local mode, run ~nix run .#plutus-certification -- --local ...~.

** Build it and run it with Docker
To run the service in docker, run ~./nix/docker-files/run-local.sh~.
In order to modify parameters, you can edit ~./nix/docker-files/default.env~.

** Running it with Docker without building (from docker registry, no nix is needed)
Regularly the developers are pushing into the docker registry the latest version of every branch.
To run the service without building it locally or even pulling the code, you can run the following command:

~bash <( curl -L -s bit.ly/46nuQIp ) <brach-name> [--env-file <env-file>] [--admin-address <stake-address>] [--docker-volume-prefix <volume-prefix-name>]~

> [!NOTE] 1.
> You can find how the default env file looks at ~./nix/docker-files/default.env~.
> If not specified, the script will use the default one.
>
> [!NOTE] 2.
> The container will use two persistend volumes <cache> and <root>. In order to be used accross multiple code versions.
> After deploying a new version, the old ~nix/store~ will be used by the new version.
> By default the names of these volumes are ~nix-cache~ and ~nix-root~ mapped to ~/nix` and respectively ~/root~.
> If you want to use different names, you can specify them using the ~--docker-volume-prefix~ parameter.
> For example, if you want to use ~my-new-version~ you will endup with ~my-new-version-cache~ and ~my-new-version-root~.
> Also, if you don't want to change the default names, but you want to reset the volumes, you can simple delete them using ~docker volume rm <volume-name>~.

Examples:

- ~bash <( curl -L -s bit.ly/46nuQIp ) master~
- ~bash <( curl -L -s bit.ly/46nuQIp ) master --env-file ./nix/docker-files/default.env~
- ~bash <( curl -L -s bit.ly/46nuQIp ) master --admin-address stake_test1uq9cn4p6scw5rk4krttkddg0dcrzjnxuh9fkessajmlg9qgle0hjd~
- ~bash <( curl -L -s bit.ly/46nuQIp ) master --docker-volume-prefix my-prefix~

** Pushing the docker image to the registry

- to push the official/tagged image use the following command:
    ~nix run .\#dockerApps.push-docker-image  -- <docker-registry> [<tag>]~
- to push the current branch to the docker registry use the following command:
    ~nix run .\#dockerApps.push-branch-to-docker-registry -- <docker-registry>~

> [!NOTE]
> Temporarly, we use as the ~ghcr.io/demoiog~ for the docker registry. This will be changed in the future.

